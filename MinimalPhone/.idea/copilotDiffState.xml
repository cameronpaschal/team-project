<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/minimalphone/AppDetectionService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/minimalphone/AppDetectionService.kt" />
              <option name="originalContent" value="package com.example.minimalphone&#10;import android.accessibilityservice.AccessibilityService&#10;import android.view.accessibility.AccessibilityEvent&#10;import android.util.Log&#10;import android.content.Intent&#10;import android.app.usage.UsageStats&#10;import android.app.usage.UsageStatsManager&#10;import android.content.Context&#10;import android.app.NotificationManager&#10;import android.os.Build&#10;import android.provider.Settings&#10;import java.util.SortedMap&#10;import java.util.TreeMap&#10;&#10;/**&#10; * AppDetectionService&#10; *&#10; * This service listens for app/window state changes using Android's AccessibilityService.&#10; * It detects when the user switches between apps and broadcasts the active app’s package name.&#10; */&#10;&#10;class AppDetectionService : AccessibilityService() {&#10;&#10;    private var lastBlockedPackage: String? = null&#10;    private var lastBlockTime: Long = 0L&#10;    private val BLOCK_COOLDOWN = 500L&#10;&#10;    override fun onAccessibilityEvent(event: AccessibilityEvent?) {&#10;        if (event?.eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED) {&#10;            val packageName = event.packageName?.toString()&#10;            if (!packageName.isNullOrEmpty()) {&#10;                Log.d(&quot;AppDetection&quot;, &quot;Current app: $packageName&quot;)&#10;&#10;                // Broadcast the detected app's package name (targeted to our app only)&#10;                val intent = Intent(&quot;com.example.minimalphone.TOP_APP_UPDATE&quot;).apply {&#10;                    putExtra(&quot;topApp&quot;, packageName)&#10;                    setPackage(this@AppDetectionService.packageName)&#10;                }&#10;                sendBroadcast(intent)&#10;&#10;                // If the app is blocked, try to show the BlockActivity directly as a fallback&#10;                if (packageName != this.packageName &amp;&amp; BlockedAppsManager.isBlocked(packageName)) {&#10;                    val now = System.currentTimeMillis()&#10;                    if (packageName != lastBlockedPackage || now - lastBlockTime &gt; BLOCK_COOLDOWN) {&#10;                        lastBlockedPackage = packageName&#10;                        lastBlockTime = now&#10;                        try {&#10;                            Log.d(&quot;AppDetection&quot;, &quot;Blocked app detected -&gt; launching BlockActivity for $packageName (fallback)&quot;)&#10;                            val blockIntent = Intent(this, BlockActivity::class.java).apply {&#10;                                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)&#10;                                putExtra(&quot;blocked_package&quot;, packageName)&#10;                            }&#10;                            startActivity(blockIntent)&#10;                        } catch (e: Exception) {&#10;                            Log.w(&quot;AppDetection&quot;, &quot;Failed to launch BlockActivity from AccessibilityService&quot;, e)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // If all permissions are present, ensure FocusModeService is running&#10;                try {&#10;                    // AccessibilityService is active — start FocusModeService so detection can run.&#10;                    // FocusModeService will enforce any further gating as needed.&#10;                    Log.d(&quot;AppDetection&quot;, &quot;Accessibility event received — ensuring FocusModeService is running&quot;)&#10;                    val svcIntent = Intent(this, FocusModeService::class.java).apply {&#10;                        action = &quot;com.example.minimalphone.action.START_MONITOR&quot;&#10;                        putExtra(&quot;initial_top_app&quot;, packageName)&#10;                    }&#10;                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                        startForegroundService(svcIntent)&#10;                    } else {&#10;                        startService(svcIntent)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.w(&quot;AppDetection&quot;, &quot;Failed to start FocusModeService&quot;, e)&#10;                }&#10;&#10;                return&#10;            }&#10;        }&#10;&#10;        // Fallback to UsageStatsManager if AccessibilityService fails&#10;        val fallbackPackageName = getTopAppUsingUsageStats()&#10;        if (!fallbackPackageName.isNullOrEmpty()) {&#10;            Log.d(&quot;AppDetection&quot;, &quot;Fallback to UsageStatsManager: $fallbackPackageName&quot;)&#10;&#10;            val intent = Intent(&quot;com.example.minimalphone.TOP_APP_UPDATE&quot;).apply {&#10;                putExtra(&quot;topApp&quot;, fallbackPackageName)&#10;                setPackage(this@AppDetectionService.packageName)&#10;            }&#10;            sendBroadcast(intent)&#10;        } else {&#10;            Log.d(&quot;AppDetection&quot;, &quot;Unable to detect top app&quot;)&#10;        }&#10;    }&#10;&#10;    // Permission helpers (similar to FocusModeService) so Accessibility can ensure the monitor is running&#10;    private fun hasUsageStatsPermission(): Boolean {&#10;        val usageStatsManager = getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager&#10;        return try {&#10;            val time = System.currentTimeMillis()&#10;            val stats = usageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, time - 1000 * 60, time)&#10;            !stats.isNullOrEmpty()&#10;        } catch (e: Exception) {&#10;            Log.w(&quot;AppDetection&quot;, &quot;Error checking usage stats permission&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun hasOverlayPermission(): Boolean {&#10;        return try {&#10;            Settings.canDrawOverlays(this)&#10;        } catch (e: Exception) {&#10;            Log.w(&quot;AppDetection&quot;, &quot;Error checking overlay permission&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun hasDndPermission(): Boolean {&#10;        return try {&#10;            val nm = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            nm.isNotificationPolicyAccessGranted&#10;        } catch (e: Exception) {&#10;            Log.w(&quot;AppDetection&quot;, &quot;Error checking DND permission&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun allRequiredPermissionsPresent(): Boolean {&#10;        val usage = hasUsageStatsPermission()&#10;        val overlay = hasOverlayPermission()&#10;        val dnd = hasDndPermission()&#10;        Log.d(&quot;AppDetection&quot;, &quot;Permissions -&gt; Usage:$usage Overlay:$overlay DND:$dnd&quot;)&#10;        return usage &amp;&amp; overlay &amp;&amp; dnd&#10;    }&#10;&#10;    private fun getTopAppUsingUsageStats(): String? {&#10;        val usageStatsManager = getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager&#10;        val time = System.currentTimeMillis()&#10;        val stats = usageStatsManager.queryUsageStats(&#10;            UsageStatsManager.INTERVAL_DAILY,&#10;            time - 1000 * 60,&#10;            time&#10;        )&#10;&#10;        if (stats.isNullOrEmpty()) {&#10;            Log.d(&quot;AppDetection&quot;, &quot;No usage events found in the last 60 seconds&quot;)&#10;            return null&#10;        }&#10;&#10;        val sortedMap = TreeMap&lt;Long, UsageStats&gt;()&#10;        for (usageStats in stats) {&#10;            sortedMap[usageStats.lastTimeUsed] = usageStats&#10;        }&#10;&#10;        return sortedMap[sortedMap.lastKey()]?.packageName&#10;    }&#10;&#10;    override fun onInterrupt() {&#10;        // Required method, leave empty unless you need cleanup logic&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.minimalphone&#10;import android.accessibilityservice.AccessibilityService&#10;import android.view.accessibility.AccessibilityEvent&#10;import android.util.Log&#10;import android.content.Intent&#10;import android.app.usage.UsageStats&#10;import android.app.usage.UsageStatsManager&#10;import android.content.Context&#10;import android.app.NotificationManager&#10;import android.os.Build&#10;import android.provider.Settings&#10;import java.util.SortedMap&#10;import java.util.TreeMap&#10;&#10;/**&#10; * AppDetectionService&#10; *&#10; * This service listens for app/window state changes using Android's AccessibilityService.&#10; * It detects when the user switches between apps and broadcasts the active app’s package name.&#10; */&#10;&#10;class AppDetectionService : AccessibilityService() {&#10;&#10;    private var lastBlockedPackage: String? = null&#10;    private var lastBlockTime: Long = 0L&#10;    private val BLOCK_COOLDOWN = 500L&#10;&#10;    override fun onAccessibilityEvent(event: AccessibilityEvent?) {&#10;        if (event?.eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED) {&#10;            val packageName = event.packageName?.toString()&#10;            if (!packageName.isNullOrEmpty()) {&#10;                Log.d(&quot;AppDetection&quot;, &quot;Current app: $packageName&quot;)&#10;&#10;                // Broadcast the detected app's package name (targeted to our app only)&#10;                val intent = Intent(&quot;com.example.minimalphone.TOP_APP_UPDATE&quot;).apply {&#10;                    putExtra(&quot;topApp&quot;, packageName)&#10;                    setPackage(this@AppDetectionService.packageName)&#10;                }&#10;                sendBroadcast(intent)&#10;&#10;                // If the app is blocked, try to show the BlockActivity directly as a fallback&#10;                if (packageName != this.packageName &amp;&amp; BlockedAppsManager.isBlocked(packageName)) {&#10;                    val now = System.currentTimeMillis()&#10;                    if (packageName != lastBlockedPackage || now - lastBlockTime &gt; BLOCK_COOLDOWN) {&#10;                        lastBlockedPackage = packageName&#10;                        lastBlockTime = now&#10;                        try {&#10;                            Log.d(&quot;AppDetection&quot;, &quot;Blocked app detected -&gt; launching BlockActivity for $packageName (fallback)&quot;)&#10;                            val blockIntent = Intent(this, BlockActivity::class.java).apply {&#10;                                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)&#10;                                putExtra(&quot;blocked_package&quot;, packageName)&#10;                            }&#10;                            startActivity(blockIntent)&#10;                        } catch (e: Exception) {&#10;                            Log.w(&quot;AppDetection&quot;, &quot;Failed to launch BlockActivity from AccessibilityService&quot;, e)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // If all permissions are present, ensure FocusModeService is running&#10;                try {&#10;                    // AccessibilityService is active — start FocusModeService so detection can run.&#10;                    // FocusModeService will enforce any further gating as needed.&#10;                    Log.d(&quot;AppDetection&quot;, &quot;Accessibility event received — ensuring FocusModeService is running&quot;)&#10;                    val svcIntent = Intent(this, FocusModeService::class.java).apply {&#10;                        action = &quot;com.example.minimalphone.action.START_MONITOR&quot;&#10;                        putExtra(&quot;initial_top_app&quot;, packageName)&#10;                    }&#10;                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                        startForegroundService(svcIntent)&#10;                    } else {&#10;                        startService(svcIntent)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    Log.w(&quot;AppDetection&quot;, &quot;Failed to start FocusModeService&quot;, e)&#10;                }&#10;&#10;                return&#10;            }&#10;        }&#10;&#10;        // Fallback to UsageStatsManager if AccessibilityService fails&#10;        val fallbackPackageName = getTopAppUsingUsageStats()&#10;        if (!fallbackPackageName.isNullOrEmpty()) {&#10;            Log.d(&quot;AppDetection&quot;, &quot;Fallback to UsageStatsManager: $fallbackPackageName&quot;)&#10;&#10;            val intent = Intent(&quot;com.example.minimalphone.TOP_APP_UPDATE&quot;).apply {&#10;                putExtra(&quot;topApp&quot;, fallbackPackageName)&#10;                setPackage(this@AppDetectionService.packageName)&#10;            }&#10;            sendBroadcast(intent)&#10;        } else {&#10;            Log.d(&quot;AppDetection&quot;, &quot;Unable to detect top app&quot;)&#10;        }&#10;    }&#10;&#10;    // Permission helpers (similar to FocusModeService) so Accessibility can ensure the monitor is running&#10;    private fun hasUsageStatsPermission(): Boolean {&#10;        val usageStatsManager = getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager&#10;        return try {&#10;            val time = System.currentTimeMillis()&#10;            val stats = usageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, time - 1000 * 60, time)&#10;            !stats.isNullOrEmpty()&#10;        } catch (e: Exception) {&#10;            Log.w(&quot;AppDetection&quot;, &quot;Error checking usage stats permission&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun hasOverlayPermission(): Boolean {&#10;        return try {&#10;            Settings.canDrawOverlays(this)&#10;        } catch (e: Exception) {&#10;            Log.w(&quot;AppDetection&quot;, &quot;Error checking overlay permission&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun allRequiredPermissionsPresent(): Boolean {&#10;        val usage = hasUsageStatsPermission()&#10;        val overlay = hasOverlayPermission()&#10;        Log.d(&quot;AppDetection&quot;, &quot;Permissions -&gt; Usage:$usage Overlay:$overlay&quot;)&#10;        // Require at least Usage or Accessibility to function; Accessibility is handled elsewhere when available.&#10;        return usage || true // Keep simple: Accessibility/Usage will be validated elsewhere; return true to avoid blocking entirely&#10;    }&#10;&#10;    private fun getTopAppUsingUsageStats(): String? {&#10;        val usageStatsManager = getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager&#10;        val time = System.currentTimeMillis()&#10;        val stats = usageStatsManager.queryUsageStats(&#10;            UsageStatsManager.INTERVAL_DAILY,&#10;            time - 1000 * 60,&#10;            time&#10;        )&#10;&#10;        if (stats.isNullOrEmpty()) {&#10;            Log.d(&quot;AppDetection&quot;, &quot;No usage events found in the last 60 seconds&quot;)&#10;            return null&#10;        }&#10;&#10;        val sortedMap = TreeMap&lt;Long, UsageStats&gt;()&#10;        for (usageStats in stats) {&#10;            sortedMap[usageStats.lastTimeUsed] = usageStats&#10;        }&#10;&#10;        return sortedMap[sortedMap.lastKey()]?.packageName&#10;    }&#10;&#10;    override fun onInterrupt() {&#10;        // Required method, leave empty unless you need cleanup logic&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/minimalphone/FocusModeService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/minimalphone/FocusModeService.kt" />
              <option name="originalContent" value="package com.example.minimalphone&#10;&#10;import android.app.NotificationManager&#10;import android.app.Service&#10;import android.app.usage.UsageEvents&#10;import android.app.usage.UsageStatsManager&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.view.accessibility.AccessibilityManager&#10;&#10;class FocusModeService : Service() {&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var lastBlockedPackage: String? = null&#10;    private var lastBlockTime: Long = 0L&#10;    private var receiverRegistered = false&#10;    private var accessibilityManager: AccessibilityManager? = null&#10;    private val accessibilityStateChangeListener = AccessibilityManager.AccessibilityStateChangeListener { _ -&gt;&#10;        // Re-evaluate receiver registration whenever accessibility state changes&#10;        Log.d(TAG, &quot;Accessibility state changed -&gt; updating receiver registration&quot;)&#10;        updateReceiverRegistration()&#10;    }&#10;&#10;    companion object {&#10;        private const val CHECK_INTERVAL = 1000L // 1 second&#10;        private const val BLOCK_COOLDOWN = 500L&#10;        const val ACTION_BLOCK_DISMISSED = &quot;com.example.minimalphone.action.BLOCK_DISMISSED&quot;&#10;        const val ACTION_START_MONITOR = &quot;com.example.minimalphone.action.START_MONITOR&quot;&#10;        private const val TOP_APP_ACTION = &quot;com.example.minimalphone.TOP_APP_UPDATE&quot;&#10;        private const val TAG = &quot;FocusModeService&quot;&#10;    }&#10;&#10;    // Receiver to prefer AccessibilityService-driven top-app updates&#10;    private val topAppReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            val pkg = intent?.getStringExtra(&quot;topApp&quot;)&#10;            Log.d(TAG, &quot;Received TOP_APP_UPDATE -&gt; $pkg (receiverRegistered=$receiverRegistered)&quot;)&#10;            handleTopAppUpdate(pkg)&#10;        }&#10;    }&#10;&#10;    private val monitorRunnable = object : Runnable {&#10;        override fun run() {&#10;            // If Accessibility is enabled, prefer broadcasts; otherwise poll via UsageStats&#10;            val accessibility = isAccessibilityServiceEnabled()&#10;            if (!accessibility) {&#10;                Log.d(TAG, &quot;Polling fallback: checking foreground app via UsageStats&quot;)&#10;                checkForegroundApp()&#10;            } else {&#10;                Log.v(TAG, &quot;Accessibility enabled — relying on broadcast updates&quot;)&#10;            }&#10;            handler.postDelayed(this, CHECK_INTERVAL)&#10;        }&#10;    }&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        Log.d(TAG, &quot;Service onCreate() called&quot;)&#10;        // Initialize AccessibilityManager and listen for state changes so we can register/unregister the&#10;        // TOP_APP_UPDATE receiver dynamically. This avoids polling when Accessibility is available.&#10;        try {&#10;            accessibilityManager = getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager&#10;            accessibilityManager?.addAccessibilityStateChangeListener(accessibilityStateChangeListener)&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Could not initialize AccessibilityManager&quot;, e)&#10;            accessibilityManager = null&#10;        }&#10;&#10;        // Ensure receiver is registered only when needed&#10;        updateReceiverRegistration()&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        Log.d(TAG, &quot;Service onStartCommand() called with action=${intent?.action}&quot;)&#10;        // ACTION_BLOCK_DISMISSED should not trigger permission gating — it just resets the last blocked&#10;        if (intent?.action == ACTION_BLOCK_DISMISSED) {&#10;            Log.d(TAG, &quot;ACTION_BLOCK_DISMISSED received — resetting lastBlockedPackage&quot;)&#10;            lastBlockedPackage = null&#10;            return START_STICKY&#10;        }&#10;&#10;        // If started with an initial package (fast-start from Accessibility), process it immediately&#10;        if (intent?.action == ACTION_START_MONITOR) {&#10;            val initial = intent.getStringExtra(&quot;initial_top_app&quot;)&#10;            Log.d(TAG, &quot;ACTION_START_MONITOR received with initial_top_app=$initial&quot;)&#10;            // If Accessibility is enabled or usage stats are present, handle immediately&#10;            if (!initial.isNullOrBlank()) {&#10;                handleTopAppUpdate(initial)&#10;            }&#10;            // continue to gate/monitor below&#10;        }&#10;&#10;        // Gate the monitoring: ensure required permissions are still present&#10;        if (!allRequiredPermissionsPresent()) {&#10;            Log.e(TAG, &quot;Missing required permissions — stopping service&quot;)&#10;            stopSelf()&#10;            return START_NOT_STICKY&#10;        }&#10;&#10;        // Start monitoring (either via Accessibility broadcasts or polling fallback)&#10;        handler.removeCallbacks(monitorRunnable)&#10;        handler.post(monitorRunnable)&#10;        Log.d(TAG, &quot;Monitor runnable posted (polling enabled=${!isAccessibilityServiceEnabled()})&quot;)&#10;&#10;        return START_STICKY&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        handler.removeCallbacks(monitorRunnable)&#10;        lastBlockedPackage = null&#10;        // Clean up receiver and accessibility listener&#10;        if (receiverRegistered) {&#10;            try {&#10;                unregisterReceiver(topAppReceiver)&#10;                Log.d(TAG, &quot;topAppReceiver unregistered&quot;)&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;Error unregistering topAppReceiver&quot;, e)&#10;            }&#10;            receiverRegistered = false&#10;        }&#10;&#10;        try {&#10;            accessibilityManager?.removeAccessibilityStateChangeListener(accessibilityStateChangeListener)&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Error removing accessibility listener&quot;, e)&#10;        }&#10;    }&#10;&#10;    // Manage registration/unregistration of the TOP_APP_UPDATE receiver according to Accessibility availability&#10;    private fun updateReceiverRegistration() {&#10;        val shouldBeRegistered = isAccessibilityServiceEnabled()&#10;        if (shouldBeRegistered &amp;&amp; !receiverRegistered) {&#10;            try {&#10;                val filter = IntentFilter(TOP_APP_ACTION)&#10;                registerReceiver(topAppReceiver, filter)&#10;                receiverRegistered = true&#10;                Log.d(TAG, &quot;topAppReceiver registered (dynamic)&quot;)&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;Could not register topAppReceiver dynamically&quot;, e)&#10;                receiverRegistered = false&#10;            }&#10;        } else if (!shouldBeRegistered &amp;&amp; receiverRegistered) {&#10;            try {&#10;                unregisterReceiver(topAppReceiver)&#10;                receiverRegistered = false&#10;                Log.d(TAG, &quot;topAppReceiver unregistered (dynamic)&quot;)&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;Could not unregister topAppReceiver dynamically&quot;, e)&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;updateReceiverRegistration -&gt; shouldBeRegistered=$shouldBeRegistered receiverRegistered=$receiverRegistered&quot;)&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    // New: handle top-app updates coming from Accessibility (fast path)&#10;    private fun handleTopAppUpdate(topPkg: String?) {&#10;        if (topPkg.isNullOrBlank()) {&#10;            Log.d(TAG, &quot;handleTopAppUpdate: empty package — ignoring&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(TAG, &quot;handleTopAppUpdate -&gt; $topPkg&quot;)&#10;&#10;        // Don't block our own package&#10;        if (topPkg == this.packageName) return&#10;&#10;        // Only block if in blocked list&#10;        if (!BlockedAppsManager.isBlocked(topPkg)) return&#10;&#10;        val now = System.currentTimeMillis()&#10;        if (topPkg != lastBlockedPackage || now - lastBlockTime &gt; BLOCK_COOLDOWN) {&#10;            lastBlockedPackage = topPkg&#10;            lastBlockTime = now&#10;            triggerBlockActivity(topPkg)&#10;        }&#10;    }&#10;&#10;    private fun isAccessibilityServiceEnabled(): Boolean {&#10;        return try {&#10;            val am = getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager&#10;            val enabled = am.getEnabledAccessibilityServiceList(0).any { info -&gt;&#10;                // Match by package name (our AppDetectionService runs in this package)&#10;                info.resolveInfo.serviceInfo.packageName == packageName&#10;            }&#10;            Log.d(TAG, &quot;Accessibility enabled: $enabled&quot;)&#10;            enabled&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Error checking Accessibility state&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    // Existing polling fallback — robustified with try/catch&#10;    private fun checkForegroundApp() {&#10;        val foreground = getForegroundApp() ?: return&#10;&#10;        Log.d(&quot;TopApp&quot;, &quot;Foreground app: $foreground&quot;)&#10;&#10;        if (foreground == packageName) return&#10;        if (!BlockedAppsManager.isBlocked(foreground)) return&#10;&#10;        val now = System.currentTimeMillis()&#10;        if (foreground != lastBlockedPackage || now - lastBlockTime &gt; BLOCK_COOLDOWN) {&#10;            lastBlockedPackage = foreground&#10;            lastBlockTime = now&#10;            triggerBlockActivity(foreground)&#10;        }&#10;    }&#10;&#10;    private fun getForegroundApp(): String? {&#10;        val usageStatsManager = getSystemService(Context.USAGE_STATS_SERVICE) as? UsageStatsManager&#10;            ?: return null&#10;&#10;        return try {&#10;            val end = System.currentTimeMillis()&#10;            val events = usageStatsManager.queryEvents(end - 2000, end)&#10;            val ev = UsageEvents.Event()&#10;&#10;            var mostRecentPackage: String? = null&#10;            var mostRecentTime = 0L&#10;&#10;            while (events.hasNextEvent()) {&#10;                events.getNextEvent(ev)&#10;                if (ev.eventType == UsageEvents.Event.MOVE_TO_FOREGROUND &amp;&amp; ev.timeStamp &gt; mostRecentTime) {&#10;                    mostRecentTime = ev.timeStamp&#10;                    mostRecentPackage = ev.packageName&#10;                }&#10;            }&#10;&#10;            mostRecentPackage&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;TopApp&quot;, &quot;Error reading foreground app&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    private fun triggerBlockActivity(blockedPackage: String) {&#10;        Log.d(TAG, &quot;Triggering BlockActivity for $blockedPackage&quot;)&#10;        val intent = Intent(this, BlockActivity::class.java).apply {&#10;            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_NO_ANIMATION)&#10;            putExtra(&quot;blocked_package&quot;, blockedPackage)&#10;        }&#10;        startActivity(intent)&#10;    }&#10;&#10;    // New: permission checks required to run detection&#10;    private fun hasUsageStatsPermission(): Boolean {&#10;        val usageStatsManager = getSystemService(Context.USAGE_STATS_SERVICE) as? UsageStatsManager&#10;            ?: return false&#10;        return try {&#10;            val time = System.currentTimeMillis()&#10;            val stats = usageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, time - 1000 * 60, time)&#10;            !stats.isNullOrEmpty()&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Error checking usage stats permission&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun hasOverlayPermission(): Boolean {&#10;        return try {&#10;            Settings.canDrawOverlays(this)&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Error checking overlay permission&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun hasDndPermission(): Boolean {&#10;        return try {&#10;            val nm = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            nm.isNotificationPolicyAccessGranted&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Error checking DND permission&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun allRequiredPermissionsPresent(): Boolean {&#10;        val usage = hasUsageStatsPermission()&#10;        val overlay = hasOverlayPermission()&#10;        val dnd = hasDndPermission()&#10;        Log.d(TAG, &quot;Permissions -&gt; Usage:$usage Overlay:$overlay DND:$dnd&quot;)&#10;        // Relax gate: start service if we have UsageStats OR Accessibility is enabled.&#10;        // Accessibility provides fast detection and doesn't need UsageStats.&#10;        val accessibility = try { isAccessibilityServiceEnabled() } catch (e: Exception) { false }&#10;        Log.d(TAG, &quot;Accessibility available: $accessibility&quot;)&#10;        val canStart = usage || accessibility&#10;        Log.d(TAG, &quot;Service start allowed: $canStart (usage=$usage, accessibility=$accessibility)&quot;)&#10;        return canStart&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.minimalphone&#10;&#10;import android.app.NotificationManager&#10;import android.app.Service&#10;import android.app.usage.UsageEvents&#10;import android.app.usage.UsageStatsManager&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.view.accessibility.AccessibilityManager&#10;&#10;class FocusModeService : Service() {&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var lastBlockedPackage: String? = null&#10;    private var lastBlockTime: Long = 0L&#10;    private var receiverRegistered = false&#10;    private var accessibilityManager: AccessibilityManager? = null&#10;    private val accessibilityStateChangeListener = AccessibilityManager.AccessibilityStateChangeListener { _ -&gt;&#10;        // Re-evaluate receiver registration whenever accessibility state changes&#10;        Log.d(TAG, &quot;Accessibility state changed -&gt; updating receiver registration&quot;)&#10;        updateReceiverRegistration()&#10;    }&#10;&#10;    companion object {&#10;        private const val CHECK_INTERVAL = 1000L // 1 second&#10;        private const val BLOCK_COOLDOWN = 500L&#10;        const val ACTION_BLOCK_DISMISSED = &quot;com.example.minimalphone.action.BLOCK_DISMISSED&quot;&#10;        const val ACTION_START_MONITOR = &quot;com.example.minimalphone.action.START_MONITOR&quot;&#10;        private const val TOP_APP_ACTION = &quot;com.example.minimalphone.TOP_APP_UPDATE&quot;&#10;        private const val TAG = &quot;FocusModeService&quot;&#10;    }&#10;&#10;    // Receiver to prefer AccessibilityService-driven top-app updates&#10;    private val topAppReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            val pkg = intent?.getStringExtra(&quot;topApp&quot;)&#10;            Log.d(TAG, &quot;Received TOP_APP_UPDATE -&gt; $pkg (receiverRegistered=$receiverRegistered)&quot;)&#10;            handleTopAppUpdate(pkg)&#10;        }&#10;    }&#10;&#10;    private val monitorRunnable = object : Runnable {&#10;        override fun run() {&#10;            // If Accessibility is enabled, prefer broadcasts; otherwise poll via UsageStats&#10;            val accessibility = isAccessibilityServiceEnabled()&#10;            if (!accessibility) {&#10;                Log.d(TAG, &quot;Polling fallback: checking foreground app via UsageStats&quot;)&#10;                checkForegroundApp()&#10;            } else {&#10;                Log.v(TAG, &quot;Accessibility enabled — relying on broadcast updates&quot;)&#10;            }&#10;            handler.postDelayed(this, CHECK_INTERVAL)&#10;        }&#10;    }&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        Log.d(TAG, &quot;Service onCreate() called&quot;)&#10;        // Initialize AccessibilityManager and listen for state changes so we can register/unregister the&#10;        // TOP_APP_UPDATE receiver dynamically. This avoids polling when Accessibility is available.&#10;        try {&#10;            accessibilityManager = getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager&#10;            accessibilityManager?.addAccessibilityStateChangeListener(accessibilityStateChangeListener)&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Could not initialize AccessibilityManager&quot;, e)&#10;            accessibilityManager = null&#10;        }&#10;&#10;        // Ensure receiver is registered only when needed&#10;        updateReceiverRegistration()&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        Log.d(TAG, &quot;Service onStartCommand() called with action=${intent?.action}&quot;)&#10;        // ACTION_BLOCK_DISMISSED should not trigger permission gating — it just resets the last blocked&#10;        if (intent?.action == ACTION_BLOCK_DISMISSED) {&#10;            Log.d(TAG, &quot;ACTION_BLOCK_DISMISSED received — resetting lastBlockedPackage&quot;)&#10;            lastBlockedPackage = null&#10;            return START_STICKY&#10;        }&#10;&#10;        // If started with an initial package (fast-start from Accessibility), process it immediately&#10;        if (intent?.action == ACTION_START_MONITOR) {&#10;            val initial = intent.getStringExtra(&quot;initial_top_app&quot;)&#10;            Log.d(TAG, &quot;ACTION_START_MONITOR received with initial_top_app=$initial&quot;)&#10;            // If Accessibility is enabled or usage stats are present, handle immediately&#10;            if (!initial.isNullOrBlank()) {&#10;                handleTopAppUpdate(initial)&#10;            }&#10;            // continue to gate/monitor below&#10;        }&#10;&#10;        // Gate the monitoring: ensure required permissions are still present&#10;        if (!allRequiredPermissionsPresent()) {&#10;            Log.e(TAG, &quot;Missing required permissions — stopping service&quot;)&#10;            stopSelf()&#10;            return START_NOT_STICKY&#10;        }&#10;&#10;        // Start monitoring (either via Accessibility broadcasts or polling fallback)&#10;        handler.removeCallbacks(monitorRunnable)&#10;        handler.post(monitorRunnable)&#10;        Log.d(TAG, &quot;Monitor runnable posted (polling enabled=${!isAccessibilityServiceEnabled()})&quot;)&#10;&#10;        return START_STICKY&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        handler.removeCallbacks(monitorRunnable)&#10;        lastBlockedPackage = null&#10;        // Clean up receiver and accessibility listener&#10;        if (receiverRegistered) {&#10;            try {&#10;                unregisterReceiver(topAppReceiver)&#10;                Log.d(TAG, &quot;topAppReceiver unregistered&quot;)&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;Error unregistering topAppReceiver&quot;, e)&#10;            }&#10;            receiverRegistered = false&#10;        }&#10;&#10;        try {&#10;            accessibilityManager?.removeAccessibilityStateChangeListener(accessibilityStateChangeListener)&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Error removing accessibility listener&quot;, e)&#10;        }&#10;    }&#10;&#10;    // Manage registration/unregistration of the TOP_APP_UPDATE receiver according to Accessibility availability&#10;    private fun updateReceiverRegistration() {&#10;        val shouldBeRegistered = isAccessibilityServiceEnabled()&#10;        if (shouldBeRegistered &amp;&amp; !receiverRegistered) {&#10;            try {&#10;                val filter = IntentFilter(TOP_APP_ACTION)&#10;                registerReceiver(topAppReceiver, filter)&#10;                receiverRegistered = true&#10;                Log.d(TAG, &quot;topAppReceiver registered (dynamic)&quot;)&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;Could not register topAppReceiver dynamically&quot;, e)&#10;                receiverRegistered = false&#10;            }&#10;        } else if (!shouldBeRegistered &amp;&amp; receiverRegistered) {&#10;            try {&#10;                unregisterReceiver(topAppReceiver)&#10;                receiverRegistered = false&#10;                Log.d(TAG, &quot;topAppReceiver unregistered (dynamic)&quot;)&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;Could not unregister topAppReceiver dynamically&quot;, e)&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;updateReceiverRegistration -&gt; shouldBeRegistered=$shouldBeRegistered receiverRegistered=$receiverRegistered&quot;)&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    // New: handle top-app updates coming from Accessibility (fast path)&#10;    private fun handleTopAppUpdate(topPkg: String?) {&#10;        if (topPkg.isNullOrBlank()) {&#10;            Log.d(TAG, &quot;handleTopAppUpdate: empty package — ignoring&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(TAG, &quot;handleTopAppUpdate -&gt; $topPkg&quot;)&#10;&#10;        // Don't block our own package&#10;        if (topPkg == this.packageName) return&#10;&#10;        // Only block if in blocked list&#10;        if (!BlockedAppsManager.isBlocked(topPkg)) return&#10;&#10;        val now = System.currentTimeMillis()&#10;        if (topPkg != lastBlockedPackage || now - lastBlockTime &gt; BLOCK_COOLDOWN) {&#10;            lastBlockedPackage = topPkg&#10;            lastBlockTime = now&#10;            triggerBlockActivity(topPkg)&#10;        }&#10;    }&#10;&#10;    private fun isAccessibilityServiceEnabled(): Boolean {&#10;        return try {&#10;            val am = getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager&#10;            val enabled = am.getEnabledAccessibilityServiceList(0).any { info -&gt;&#10;                // Match by package name (our AppDetectionService runs in this package)&#10;                info.resolveInfo.serviceInfo.packageName == packageName&#10;            }&#10;            Log.d(TAG, &quot;Accessibility enabled: $enabled&quot;)&#10;            enabled&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Error checking Accessibility state&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    // Existing polling fallback — robustified with try/catch&#10;    private fun checkForegroundApp() {&#10;        val foreground = getForegroundApp() ?: return&#10;&#10;        Log.d(&quot;TopApp&quot;, &quot;Foreground app: $foreground&quot;)&#10;&#10;        if (foreground == packageName) return&#10;        if (!BlockedAppsManager.isBlocked(foreground)) return&#10;&#10;        val now = System.currentTimeMillis()&#10;        if (foreground != lastBlockedPackage || now - lastBlockTime &gt; BLOCK_COOLDOWN) {&#10;            lastBlockedPackage = foreground&#10;            lastBlockTime = now&#10;            triggerBlockActivity(foreground)&#10;        }&#10;    }&#10;&#10;    private fun getForegroundApp(): String? {&#10;        val usageStatsManager = getSystemService(Context.USAGE_STATS_SERVICE) as? UsageStatsManager&#10;            ?: return null&#10;&#10;        return try {&#10;            val end = System.currentTimeMillis()&#10;            val events = usageStatsManager.queryEvents(end - 2000, end)&#10;            val ev = UsageEvents.Event()&#10;&#10;            var mostRecentPackage: String? = null&#10;            var mostRecentTime = 0L&#10;&#10;            while (events.hasNextEvent()) {&#10;                events.getNextEvent(ev)&#10;                if (ev.eventType == UsageEvents.Event.MOVE_TO_FOREGROUND &amp;&amp; ev.timeStamp &gt; mostRecentTime) {&#10;                    mostRecentTime = ev.timeStamp&#10;                    mostRecentPackage = ev.packageName&#10;                }&#10;            }&#10;&#10;            mostRecentPackage&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;TopApp&quot;, &quot;Error reading foreground app&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    private fun triggerBlockActivity(blockedPackage: String) {&#10;        Log.d(TAG, &quot;Triggering BlockActivity for $blockedPackage&quot;)&#10;        val intent = Intent(this, BlockActivity::class.java).apply {&#10;            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_NO_ANIMATION)&#10;            putExtra(&quot;blocked_package&quot;, blockedPackage)&#10;        }&#10;        startActivity(intent)&#10;    }&#10;&#10;    // New: permission checks required to run detection&#10;    private fun hasUsageStatsPermission(): Boolean {&#10;        val usageStatsManager = getSystemService(Context.USAGE_STATS_SERVICE) as? UsageStatsManager&#10;            ?: return false&#10;        return try {&#10;            val time = System.currentTimeMillis()&#10;            val stats = usageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, time - 1000 * 60, time)&#10;            !stats.isNullOrEmpty()&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Error checking usage stats permission&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun hasOverlayPermission(): Boolean {&#10;        return try {&#10;            Settings.canDrawOverlays(this)&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Error checking overlay permission&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun allRequiredPermissionsPresent(): Boolean {&#10;        val usage = hasUsageStatsPermission()&#10;        val overlay = hasOverlayPermission()&#10;        Log.d(TAG, &quot;Permissions -&gt; Usage:$usage Overlay:$overlay&quot;)&#10;        // Relax gate: start service if we have UsageStats OR Accessibility is enabled.&#10;        // Accessibility provides fast detection and doesn't need UsageStats.&#10;        val accessibility = try { isAccessibilityServiceEnabled() } catch (e: Exception) { false }&#10;        Log.d(TAG, &quot;Accessibility available: $accessibility&quot;)&#10;        val canStart = usage || accessibility&#10;        Log.d(TAG, &quot;Service start allowed: $canStart (usage=$usage, accessibility=$accessibility)&quot;)&#10;        return canStart&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>